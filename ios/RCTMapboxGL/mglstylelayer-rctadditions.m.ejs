<%
  const layers = locals.layers;

  function camelize (str) {
    return str.replace(/-(.)/g, function (_, x) {
      return x.toUpperCase();
    });
  }

  function upperCamelize (str) {
    return str.replace(/(?:^|-)(.)/g, function (_, x) {
      return x.toUpperCase();
    });
  }

  const compFilterNames = ['==', '!=', '<', '<=', '>', '>=']
-%>
//
// Copyright (c) 2016 Mapbox. All rights reserved.
//
// This file is generated. See scripts/generate-layer-factory.js

#import "MGLStyleLayer+RCTAdditions.h"
#import "UIColor+RCTAdditions.h"
#import <CoreGraphics/CGGeometry.h>
<% for (const layer of layers) { -%>
#import <Mapbox/MGL<%- upperCamelize(layer.type) -%>StyleLayer.h>
<% } -%>

NSString *const RCTMapboxGLErrorDomain = @"com.mapbox.reactnativemapboxgl.ErrorDomain";


@implementation MGLStyleLayer (RCTAdditions)

+ (MGLStyleLayer *)styleLayerWithJson:(nonnull NSDictionary *)layerJson
                   mapView:(RCTMapboxGL *)mapView
                   error:(NSError **)errorPtr
{
    NSString *idString = layerJson[@"id"];
    NSString *typeString = layerJson[@"type"];

    NSString *ref = layerJson[@"ref"];
    if (ref) {
        if (errorPtr) {
            *errorPtr = [NSError errorWithDomain:RCTMapboxGLErrorDomain
                                 code:1002
                                 userInfo:@{NSLocalizedDescriptionKey:[NSString stringWithFormat:@"addLayer(): cannot use property 'ref' in layer '%@'", idString]}
            ];
        }
        return nil;
    }

<% for (const layer of layers) { -%>
    if([typeString isEqualToString:@"<%- layer.type %>"]) {
        NSDictionary *paintProperties = layerJson[@"paint"];
<% if (layer.layoutProperties.length) { -%>
        NSDictionary *layoutProperties = layerJson[@"layout"];
<% } -%>
<% if (layer.type === 'background') { -%>
        MGL<%- upperCamelize(layer.type) %>StyleLayer *layer = [[MGL<%- upperCamelize(layer.type) %>StyleLayer alloc] initWithIdentifier:idString];
<% } else { -%>
        NSString *sourceString = layerJson[@"source"];
        if (!sourceString) {
            if (errorPtr) {
                *errorPtr = [NSError errorWithDomain:RCTMapboxGLErrorDomain
                                     code:1003
                                     userInfo:@{NSLocalizedDescriptionKey:[NSString stringWithFormat:@"addLayer(): layer of type '%@' must have a 'source' attribute", typeString]}
                ];
            }
            return nil;
        }
        MGLSource *source = [mapView styleSourceWithIdentifier:sourceString];
        if (!source) {
            if (errorPtr) {
                *errorPtr = [NSError errorWithDomain:RCTMapboxGLErrorDomain
                                     code:1004
                                     userInfo:@{NSLocalizedDescriptionKey:[NSString stringWithFormat:@"addLayer(): source '%@' for layer '%@' is nil", sourceString, idString]}
                ];
            }
            return nil;
        }
        MGL<%- upperCamelize(layer.type) %>StyleLayer *layer = [[MGL<%- upperCamelize(layer.type) %>StyleLayer alloc] initWithIdentifier:idString source:source];
<% } -%>
<% for (const prop of layer.properties) { -%>
        if ([<%- prop.propertyType %>Properties valueForKey:@"<%- prop.name %>"]) {
<% if (prop.type === 'enum') { -%>
            // create the NSString -> enum dictionary for later use
            NSDictionary<NSString*, NSNumber *> *enumDictionary = @{
<% for (const val in prop.values) { -%>
                @"<%- val %>": @(MGL<%- upperCamelize(prop.setterName || prop.name) %><%- upperCamelize(val) %>),
<% } -%>
            };
<% } -%>
<% if (prop['zoom-function'] === true) { -%>
            NSExpression *exp;
            if ([[<%- prop.propertyType %>Properties valueForKey:@"<%- prop.name %>"] isKindOfClass:[NSDictionary class]]) {
                NSArray *stops = <%- prop.propertyType %>Properties[@"<%- prop.name %>"][@"stops"];
                NSMutableDictionary *stopsDict = [[NSMutableDictionary alloc] init];
                for (id stop in stops) {
<% if (prop.type === 'color') { -%>
                    [stopsDict setObject:[UIColor colorWithString:stop[1]] forKey:stop[0]];
<% } else if (prop.type === 'enum') { -%>
                    NSValue *value = [NSValue valueWithMGL<%- upperCamelize(prop.setterName || prop.name) %>:enumDictionary[<%- prop.propertyType %>Properties[@"<%- prop.name %>"]].integerValue];
                    // // [stopsDict setObject:[MGLStyleValue valueWithRawValue:value] forKey:stop[0]];
                    [stopsDict setObject:value forKey:stop[0]];
<% } else if (prop.name.includes('icon-text-fit-padding')) { -%>
                    NSArray *<%- camelize(prop.name) %>Array = stop[1];
                    UIEdgeInsets insets = UIEdgeInsetsMake([<%- camelize(prop.name) %>Array[0] floatValue], [<%- camelize(prop.name) %>Array[3] floatValue], [<%- camelize(prop.name) %>Array[2] floatValue], [<%- camelize(prop.name) %>Array[1] floatValue]);
                //    [stopsDict setObject:[MGLStyleValue valueWithRawValue:[NSValue valueWithUIEdgeInsets:insets]] forKey:stop[0]];
                    [stopsDict setObject:[NSValue valueWithUIEdgeInsets:insets] forKey:stop[0]];
<% } else if ((prop.name.includes('offset') || prop.name.includes('translate')) && !prop.name.includes('line-offset')) { -%>
                    CGVector vector = CGVectorMake([stop[1][0] floatValue], [stop[1][1] floatValue]);
                //    [stopsDict setObject:[MGLStyleValue valueWithRawValue:[NSValue valueWithCGVector:vector]] forKey:stop[0]];
                    [stopsDict setObject:[NSValue valueWithCGVector:vector] forKey:stop[0]];
<% } else { -%>
                //    // [stopsDict setObject:[MGLStyleValue valueWithRawValue:stop[1]] forKey:stop[0]];
                    [stopsDict setObject:stop[1] forKey:stop[0]];
<% } -%>
                }
<% if (prop.function === 'interpolated') { -%>
                NSMutableDictionary *optionsDict = [[NSMutableDictionary alloc] init];
                NSNumber *baseNumber = <%- prop.propertyType %>Properties[@"<%- prop.name %>"][@"base"];
                if (baseNumber) {
                    // [optionsDict setObject:baseNumber forKey:MGLStyleFunctionOptionInterpolationBase];
                    exp = [NSExpression
                            mgl_expressionForInterpolatingExpression:NSExpression.zoomLevelVariableExpression
                            withCurveType:MGLExpressionInterpolationModeExponential
                            parameters:[NSExpression expressionForConstantValue:baseNumber]
                            stops:[NSExpression expressionForConstantValue:stopsDict]];
                } else {
                    // [optionsDict setObject:[NSNumber numberWithInt:1] forKey:MGLStyleFunctionOptionInterpolationBase];
                    // exp = [NSExpression expressionWithFormat: @"mgl_interpolate:withCurveType:parameters:stops:(mag, 'exponential', nil, %@)", stops];
                    exp = [NSExpression
                            mgl_expressionForInterpolatingExpression:NSExpression.zoomLevelVariableExpression
                            withCurveType:MGLExpressionInterpolationModeLinear
                            parameters:nil
                            stops:[NSExpression expressionForConstantValue:stopsDict]];
                }
                // MGLStyleValue *<%- camelize(prop.name) %>Value = [MGLStyleValue valueWithInterpolationMode:MGLInterpolationModeExponential cameraStops:stopsDict options:optionsDict];
<% } else { -%>
                // MGLStyleValue *<%- camelize(prop.name) %>Value = [MGLStyleValue valueWithInterpolationMode:MGLInterpolationModeInterval cameraStops:stopsDict options:nil];
                //// exp = [NSExpression expressionForConstantValue:<%- prop.propertyType %>Properties[@"<%- prop.name %>"]];
                // exp = [NSExpression expressionWithFormat: @"mgl_step:from:stops:(mag, nil, %@)", stopsDict];
                exp = [NSExpression
                       mgl_expressionForSteppingExpression:NSExpression.zoomLevelVariableExpression
                       fromExpression:[NSExpression expressionForConstantValue:stops[0][1]]
                       stops:[NSExpression expressionForConstantValue:stopsDict]];
<% } -%>
                // [layer set<%- upperCamelize(prop.setterName || prop.name) %>:<%- camelize(prop.name) %>Value];
                [layer set<%- upperCamelize(prop.setterName || prop.name) %>:exp];
            } else {
<% } -%>
<% if (prop.type === 'color') { -%>
                UIColor *color = [UIColor colorWithString:<%- prop.propertyType %>Properties[@"<%- prop.name %>"]];
                // MGLStyleValue *<%- camelize(prop.name) %>Value = [MGLStyleValue valueWithRawValue:color];
                exp = [NSExpression expressionForConstantValue:color];
<% } else if (prop.type === 'enum') { -%>
                NSValue *value = [NSValue valueWithMGL<%- upperCamelize(prop.setterName || prop.name) %>:enumDictionary[<%- prop.propertyType %>Properties[@"<%- prop.name %>"]].integerValue];
                // MGLStyleValue *<%- camelize(prop.name) %>Value = [MGLStyleValue valueWithRawValue:value];
                exp = [NSExpression expressionForConstantValue:value];
<% } else if (prop.name.includes('icon-text-fit-padding')) { -%>
                // NSArray *<%- camelize(prop.name) %>Array = layoutProperties[@"<%- prop.name %>"];
                // UIEdgeInsets insets = UIEdgeInsetsMake([<%- camelize(prop.name) %>Array[0] floatValue], [<%- camelize(prop.name) %>Array[3] floatValue], [<%- camelize(prop.name) %>Array[2] floatValue], [<%- camelize(prop.name) %>Array[1] floatValue]);
                // MGLStyleValue *<%- camelize(prop.name) %>Value = [MGLStyleValue valueWithRawValue:[NSValue valueWithUIEdgeInsets:insets]];
                exp = [NSExpression expressionForConstantValue:<%- prop.propertyType %>Properties[@"<%- prop.name %>"]];
<% } else if ((prop.name.includes('offset') || prop.name.includes('translate')) && !prop.name.includes('line-offset')) { -%>
                // CGVector vector = CGVectorMake([<%- prop.propertyType %>Properties[@"<%- prop.name %>"][0] floatValue], [<%- prop.propertyType %>Properties[@"<%- prop.name %>"][1] floatValue]);
                // MGLStyleValue *<%- camelize(prop.name) %>Value = [MGLStyleValue valueWithRawValue:[NSValue valueWithCGVector:vector]];
                exp = [NSExpression expressionForConstantValue:<%- prop.propertyType %>Properties[@"<%- prop.name %>"]];
<% } else { -%>
                // MGLStyleValue *<%- camelize(prop.name) %>Value = [MGLStyleValue valueWithRawValue:<%- prop.propertyType %>Properties[@"<%- prop.name %>"]];
                exp = [NSExpression expressionForConstantValue:<%- prop.propertyType %>Properties[@"<%- prop.name %>"]];
<% } -%>
                // [layer set<%- upperCamelize(prop.setterName || prop.name) %>:<%- camelize(prop.name) %>Value];
                [layer set<%- upperCamelize(prop.setterName || prop.name) %>:exp];
<% if (prop['zoom-function'] === true) { -%>
            }
<% } -%>
        }
<% } -%>
<% if (layer.type !== 'background' && layer.type !== 'raster') { -%>
        NSString *sourceLayer = layerJson[@"source-layer"];
        NSArray *filter = layerJson[@"filter"];
        if (sourceLayer) {
            [layer setSourceLayerIdentifier:sourceLayer];
        }
        if (filter) {
            [layer setPredicate:[layer predicateWithJson:filter]];
        }
<% } -%>

        NSNumber *minzoom = layerJson[@"minzoom"];
        NSNumber *maxzoom = layerJson[@"maxzoom"];
        if (minzoom) {
            [layer setMinimumZoomLevel:[minzoom floatValue]];
        }
        if (maxzoom) {
            [layer setMaximumZoomLevel:[maxzoom floatValue]];
        }
        return layer;
    }
<% } -%>
    if (errorPtr) {
        *errorPtr = [NSError errorWithDomain:RCTMapboxGLErrorDomain
                             code:1001
                             userInfo:@{NSLocalizedDescriptionKey:[NSString stringWithFormat:@"addLayer(): cannot add layer of type '%@'", typeString]}
        ];
    }
    return nil;
}

- (NSPredicate *)predicateWithJson:(nonnull NSArray *)filterJson
{
    NSString *filterType = filterJson[0];
<% for (const filterName of compFilterNames) { -%>
    if ([filterType isEqualToString:@"<%- filterName %>"]) {
        return [NSPredicate predicateWithFormat:@"%K <%- filterName %> %@", filterJson[1], filterJson[2]];
    }
<% } -%>
    if ([filterType isEqualToString:@"has"]) {
        return [NSPredicate predicateWithFormat:@"%K != %@", filterJson[1], nil];
    }
    if ([filterType isEqualToString:@"!has"]) {
        return [NSPredicate predicateWithFormat:@"%K == %@", filterJson[1], nil];
    }
    if ([filterType isEqualToString:@"in"]) {
        NSMutableArray *elementsArray = [NSMutableArray arrayWithArray:filterJson];
        [elementsArray removeObjectAtIndex:0];
        [elementsArray removeObjectAtIndex:0];
        return [NSPredicate predicateWithFormat:@"%K IN %@", filterJson[1], elementsArray];
    }
    if ([filterType isEqualToString:@"!in"]) {
        NSMutableArray *elementsArray = [NSMutableArray arrayWithArray:filterJson];
        [elementsArray removeObjectAtIndex:0];
        [elementsArray removeObjectAtIndex:0];
        return [NSPredicate predicateWithFormat:@"!(%K IN %@)", filterJson[1], elementsArray];
    }
    if ([filterType isEqualToString:@"all"]) {
        NSMutableArray *filters = [NSMutableArray arrayWithArray:filterJson];
        [filters removeObjectAtIndex:0];
        NSMutableArray *predicates = [NSMutableArray arrayWithCapacity:[filters count]];
        for (id filter in filters) {
            [predicates addObject:[self predicateWithJson:filter]];
        }
        return [NSCompoundPredicate andPredicateWithSubpredicates:predicates];
    }
    if ([filterType isEqualToString:@"any"]) {
        NSMutableArray *filters = [NSMutableArray arrayWithArray:filterJson];
        [filters removeObjectAtIndex:0];
        NSMutableArray *predicates = [NSMutableArray arrayWithCapacity:[filters count]];
        for (id filter in filters) {
            [predicates addObject:[self predicateWithJson:filter]];
        }
        return [NSCompoundPredicate orPredicateWithSubpredicates:predicates];
    }
    if ([filterType isEqualToString:@"none"]) {
        NSMutableArray *filters = [NSMutableArray arrayWithArray:filterJson];
        [filters removeObjectAtIndex:0];
        NSMutableArray *predicates = [NSMutableArray arrayWithCapacity:[filters count]];
        for (id filter in filters) {
            [predicates addObject:[NSCompoundPredicate notPredicateWithSubpredicate:[self predicateWithJson:filter]]];
        }
        return [NSCompoundPredicate andPredicateWithSubpredicates:predicates];
    }
    return nil;
}

@end
